# Task #5 - Check Root Hidden Fields

## Summary

Analyzed the provider's Create method for hidden fields in the root properties block of `azurerm_resource_group`. Found **NO hidden fields** in `body.properties` - the properties object is empty except for the read-only field `provisioningState`. No hardcoded values, no post-creation operations, and no locks detected.

## Create Phase Verification

**Pattern:** Single-phase creation (one `CreateOrUpdate` operation only)

**Evidence from Create method:**
```go
func resourceResourceGroupCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    client := meta.(*clients.Client).Resource.ResourceGroupsClient
    ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
    defer cancel()

    id := commonids.NewResourceGroupID(meta.(*clients.Client).Account.SubscriptionId, d.Get("name").(string))

    existing, err := client.Get(ctx, id)
    if err != nil {
        if !response.WasNotFound(existing.HttpResponse) {
            return fmt.Errorf("checking for presence of existing %s: %+v", id, err)
        }
    }

    if !response.WasNotFound(existing.HttpResponse) {
        return tf.ImportAsExistsError("azurerm_resource_group", id.ID())
    }

    parameters := resourcegroups.ResourceGroup{
        Location: location.Normalize(d.Get("location").(string)),
        Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
    }

    if v := d.Get("managed_by").(string); v != "" {
        parameters.ManagedBy = pointer.To(v)
    }

    if _, err := client.CreateOrUpdate(ctx, id, parameters); err != nil {
        return fmt.Errorf("creating %q: %+v", id, err)
    }

    // custom poller to account for replication delays in the eventual consistency responses of newly created RG resources
    pollerType := custompollers.NewResourceGroupCreatePoller(client, id)
    poller := pollers.NewPoller(pollerType, 10*time.Second, pollers.DefaultNumberOfDroppedConnectionsToAllow)
    if err = poller.PollUntilDone(ctx); err != nil {
        return err
    }

    d.SetId(id.ID())
    if err := pluginsdk.SetResourceIdentityData(d, &id); err != nil {
        return err
    }

    return resourceResourceGroupRead(d, meta)
}
```

**Decision:** This is a single-phase creation with only one `CreateOrUpdate` operation. All fields belong to the Create phase and go into `local.body`.

## Hidden Fields Analysis

**Fields in Create method request body:**
1. `Location` - From schema (`location`)
2. `Tags` - From schema (`tags`)
3. `ManagedBy` - From schema (`managed_by`)

**All fields are exposed in the Terraform schema.** No hidden fields detected.

## Azure API Schema Verification

**Query:** `Microsoft.Resources/resourceGroups@2023-07-01`

**Properties schema:**
```
body.properties: EmptyObject
```

**Full body documentation:**
```json
{
  "body": {
    "location": "The location of the resource group. It cannot be changed after the resource group has been created. It must be one of the supported Azure locations. (Required)",
    "managedBy": "The ID of the resource that manages this resource group.",
    "properties": {
      "provisioningState": "The provisioning state. (ReadOnly)"
    },
    "tags": {}
  }
}
```

**Findings:**
- `properties` is an empty object
- The only field in `properties` is `provisioningState` which is **ReadOnly**
- No writable fields exist in `body.properties`

## Post-Creation Operations Analysis

**Evidence from Create method:** The Create method only executes one SDK operation:
```go
if _, err := client.CreateOrUpdate(ctx, id, parameters); err != nil {
    return fmt.Errorf("creating %q: %+v", id, err)
}
```

After the primary create, there is only polling logic (custom poller) and read operations - no additional SDK create/update operations.

**Decision:** No post-creation operations detected. No `post_creation<idx>` or `post_update<idx>` locals needed.

## Locks Detection

**Checked methods:** Create, Update, Delete

**Create method:** No lock patterns found
**Update method:** No lock patterns found
**Delete method:** No lock patterns found

**Evidence from Delete method:**
```go
func resourceResourceGroupDelete(d *pluginsdk.ResourceData, meta interface{}) error {
    client := meta.(*clients.Client).Resource.ResourceGroupsClient
    ctx, cancel := timeouts.ForDelete(meta.(*clients.Client).StopContext, d)
    defer cancel()

    id, err := commonids.ParseResourceGroupIDInsensitively(d.Id())
    if err != nil {
        return err
    }

    // conditionally check for nested resources and error if they exist
    if meta.(*clients.Client).Features.ResourceGroup.PreventDeletionIfContainsResources {
        // Resource groups sometimes hold on to resource information after the resources have been deleted. We'll retry this check to account for that eventual consistency.
        deletePollerContext, deletePollerCancel := context.WithTimeout(context.Background(), 10*time.Minute)
        defer deletePollerCancel()

        pollerType := custompollers.NewResourceGroupPreventDeletePoller(client, *id)
        poller := pollers.NewRetryOnErrorPoller(pollerType, 10*time.Second, pollers.DefaultNumberOfDroppedConnectionsToAllow, true)
        if err := poller.PollUntilDone(deletePollerContext); err != nil {
            return err
        }
    }

    if resp, err := client.Delete(ctx, *id, resourcegroups.DefaultDeleteOperationOptions()); err != nil {
        if response.WasNotFound(resp.HttpResponse) {
            return nil
        }

        return fmt.Errorf("deleting %s: %+v", *id, err)
    } else {
        if err := resp.Poller.PollUntilDone(ctx); err != nil {
            return fmt.Errorf("polling deleting %s: %+v", *id, err)
        }
    }

    return nil
}
```

No lock patterns (`locks.ByName`, `locks.MultipleByName`) found in any CRUD method.

**Decision:** `local.locks` remains empty array `[]`.

## Implementation

**No changes needed** - `migrate_main.tf` already has correct implementation:

```hcl
locals {
  body = {
    managedBy  = var.managed_by
    properties = {}  # Empty object, no hidden fields
  }
  
  locks = []  # No locks detected
}
```

The `properties = {}` is correct as:
1. No hidden fields exist in the provider Create method
2. Azure API schema shows `properties` is an empty object with only read-only fields
3. No hardcoded values are set by the provider

## Critical Review & Edge Case Analysis

**Null semantics:**
- `properties = {}` always sends empty object to API (correct behavior)
- Azure API ignores empty properties object
- No nullable fields in properties block

**Boundary conditions:**
- Empty properties object is valid and expected
- No array fields to consider
- No optional nested blocks

**Idempotency:**
- Empty properties object is deterministic
- No order-dependent logic
- No collection fields

**Safe references:**
- No nested property access required
- All references are to top-level variables

**Edge cases:**
- Resource group has no writable properties beyond root-level fields
- All schema fields are already handled in previous tasks
- No complex transformations or conditional logic needed

## Checklist

- ✅ Checked Create method for hidden fields
- ✅ Verified Azure API schema for properties structure
- ✅ Confirmed no hardcoded values in provider
- ✅ Checked for post-creation operations (none found)
- ✅ Checked all CRUD methods for lock patterns (none found)
- ✅ Verified `local.body.properties` is correctly empty
- ✅ Verified `local.locks` is correctly empty array
- ✅ No changes needed to existing implementation
- ✅ Edge case analysis completed
- ✅ Self-review: Only checked root hidden fields (task scope)

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-23
**Task:** #5 - __check_root_hidden_fields__

### Validation Results

✅ **Hidden Fields Analysis:** Complete analysis of Create method and Azure API schema - correctly determined no hidden fields exist
✅ **Post-Creation Operations:** Correctly identified single-phase creation pattern with no post-operations
✅ **Lock Detection:** All CRUD methods checked - correctly determined no locks needed
✅ **Azure API Schema Verification:** Confirmed properties is empty object with only read-only field (provisioningState)
✅ **Implementation Correctness:** `properties = {}` and `locks = []` are correct
✅ **Phase Detection:** Correctly identified single-phase creation pattern
✅ **Documentation Quality:** Comprehensive evidence provided from provider source code and API schema
✅ **Edge Cases:** All edge cases properly analyzed (empty properties object is valid)

### Compliance Statement

This implementation EXACTLY follows executor.md requirements for Type 2 tasks. All mandatory checks were performed:
- Complete Create method analysis with Go code evidence
- Azure API schema verification 
- Multi-phase operation detection (correctly identified single-phase)
- Lock pattern detection in all CRUD methods
- Correct determination that no hidden fields, no post-operations, and no locks exist

The implementation correctly uses empty properties object and empty locks array, matching both provider behavior and Azure API schema.

**Status:** APPROVED ✅

---
