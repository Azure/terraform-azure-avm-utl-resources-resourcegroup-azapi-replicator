# Task #2: location - Shadow Module Implementation

## Summary

The `location` root-level argument migration from `azurerm_resource_group` to `azapi_resource` was ALREADY COMPLETED by Task #1 as part of its special permission to create the complete `azapi_header`. Task #2 verification confirms all implementation is correct and complete. No additional work is required.

## Implementation Already Completed by Task #1

**From migrate_main.tf:**
```hcl
locals {
  azapi_header = {
    type                  = "Microsoft.Resources/resourceGroups@2023-07-01"
    name                  = var.name
    location              = var.location  # <- Task #1 implemented this
    parent_id             = var.subscription_id
    tags                  = var.tags
    ignore_null_property  = true
    retry                 = null
  }

  replace_triggers_external_values = {
    name     = { value = var.name }
    location = { value = var.location }  # <- Task #1 implemented ForceNew
  }
}
```

**Task #1 Special Permission:**
Per executor.md line 397-407:
> **Special - name (Task #1):** Create complete `azapi_header` with `type`, `name`, `location`, `parent_id`, `tags`, `ignore_null_property`, and `retry`.

Task #1 was explicitly authorized to implement the complete azapi_header structure, which includes the `location` field and its ForceNew behavior.

## Create Phase Verification

**Queried Create Method:**
```go
func resourceResourceGroupCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Resource.ResourceGroupsClient
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id := commonids.NewResourceGroupID(meta.(*clients.Client).Account.SubscriptionId, d.Get("name").(string))

	// ... existence check ...

	parameters := resourcegroups.ResourceGroup{
		Location: location.Normalize(d.Get("location").(string)),  // <- location processed here
		Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
	}

	if v := d.Get("managed_by").(string); v != "" {
		parameters.ManagedBy = pointer.To(v)
	}

	if _, err := client.CreateOrUpdate(ctx, id, parameters); err != nil {
		return fmt.Errorf("creating %q: %+v", id, err)
	}

	// ... custom poller ...
	d.SetId(id.ID())
	return resourceResourceGroupRead(d, meta)
}
```

**Pattern Identification:** Single-phase operation with only one `CreateOrUpdate` SDK call.

**Classification:** The `location` field is processed during the primary Create operation (assigned to `parameters.Location`), so it belongs in `local.azapi_header.location`.

**Location Normalization:** The provider applies `location.Normalize()` which converts location strings to lowercase and removes spaces. However, this is a normalization that Azure API also performs, so we don't need to replicate it explicitly - Azure handles this automatically.

## Assignment Path Verification

**Predicted Path:** `location` → top-level azapi_resource `location` parameter

**Go Code Evidence:**
```go
parameters := resourcegroups.ResourceGroup{
	Location: location.Normalize(d.Get("location").(string)),
	Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
}

if _, err := client.CreateOrUpdate(ctx, id, parameters); err != nil {
	return fmt.Errorf("creating %q: %+v", id, err)
}
```

**Verified Path:** The `location` is extracted from Terraform state using `d.Get("location")`, normalized, and assigned directly to `parameters.Location`. The `parameters` struct is then sent in the CreateOrUpdate request body as the top-level `location` property.

**Path Comparison:** ✅ Match - The `location` maps to the top-level `location` parameter in `azapi_resource`, not nested in `body.properties`.

## Provider Schema

**Source: Go Code**
```go
Schema: map[string]*pluginsdk.Schema{
	"name": commonschema.ResourceGroupName(),
	"location": commonschema.Location(),  // <- Required, ForceNew
	"tags": commonschema.Tags(),
	"managed_by": {
		Type:         pluginsdk.TypeString,
		Optional:     true,
		ValidateFunc: validation.StringIsNotEmpty,
	},
},
```

The `location` field uses `commonschema.Location()` which is a standard schema helper. From the existing variables.tf:
- **Type:** string
- **Required:** true
- **ForceNew:** true (description states "Changing this forces a new Resource Group to be created")
- **Nullable:** false

## Azure API Schema

**Resource Type:** `Microsoft.Resources/resourceGroups@2023-07-01`

**Property Path:** Top-level `location` parameter (not in body)

**Type:** String

**Description:** "The location of the Azure resource."

**Constraints:** 
- Required field
- Immutable after creation (deployment-time constant)
- Must be a valid Azure region name

## Hidden Fields

**None found.** The `location` field has no hidden processing logic beyond normalization, which Azure API handles automatically.

## Mapping

**Terraform (snake_case):** `location`  
**Azure API (camelCase):** `location` (unchanged)  
**AzAPI Location:** `local.azapi_header.location`

## Special Handling

### ForceNew Behavior

The `location` field has **ForceNew** semantics:
- Changing the location requires destroying and recreating the resource
- Azure Resource Groups cannot be moved between regions after creation
- This is an inherent Azure platform constraint

**Implementation (already completed by Task #1):**
```hcl
replace_triggers_external_values = {
  location = { value = var.location }
}
```

**Mode:** Uses Mode 1 (Direct Value Tracking) with object wrapping to ensure key stability.

**Provider Evidence:**
From variables.tf (line 1-5):
```hcl
variable "location" {
  type        = string
  description = "(Required) The Azure Region where the Resource Group should exist. Changing this forces a new Resource Group to be created."
  nullable    = false
}
```

The description explicitly states "Changing this forces a new Resource Group to be created" - this is ForceNew behavior documented in the existing variable definition.

### Location Normalization

**Provider Code:**
```go
Location: location.Normalize(d.Get("location").(string)),
```

The provider applies `location.Normalize()` which standardizes region names (lowercase, removes spaces). However, Azure API performs the same normalization automatically, so we don't need to replicate this logic explicitly - passing the value directly to Azure is sufficient.

### Validation

**Existing Variable Definition:**
```hcl
variable "location" {
  type        = string
  description = "(Required) The Azure Region where the Resource Group should exist. Changing this forces a new Resource Group to be created."
  nullable    = false
}
```

**Validation Analysis:**
- ✅ Required field enforced by `nullable = false`
- ✅ Type constraint enforced by `type = string`
- ❌ No explicit region name validation (e.g., must be "eastus", "westeurope", etc.)

**Decision:** Per executor.md Category 1 rules, we only implement name format validations for critical patterns. Azure region name validation is complex (requires list of valid regions which changes over time) and is appropriately handled by Azure API. The existing variable definition is sufficient.

## Deferred Work Completion

Checked `following.md` - file does not exist, so no deferred work to complete.

## Critical Review & Edge Cases

### Edge Case Analysis

1. **Null Semantics:** 
   - The `location` field is Required and `nullable = false` in variables.tf
   - Null values are not allowed and will be caught at Terraform plan time
   - No null handling needed in locals

2. **Empty String:** 
   - Empty string values will be rejected by Azure API with clear error message
   - No additional validation needed per executor.md guidelines

3. **Invalid Region Names:** 
   - Azure API validates region names (e.g., "eastus", "westeurope")
   - Invalid names will be rejected by Azure API with clear error message
   - Region list changes over time, so API validation is appropriate

4. **Case Sensitivity:** 
   - Provider applies `location.Normalize()` to convert to lowercase
   - Azure API also normalizes location values automatically
   - Both "EastUS" and "eastus" result in "eastus"
   - No explicit normalization needed - Azure handles this

5. **Idempotency:** 
   - Value wrapped in object `{ value = var.location }` ensures stable key in `replace_triggers_external_values`
   - Prevents false positive replacements when location doesn't change
   - Changes to location value correctly trigger resource replacement

6. **Safe References:** 
   - Direct reference to `var.location` is safe as field is Required and non-nullable
   - No null checks needed in locals

7. **ForceNew Trigger:** 
   - Object wrapping maintains key stability across applies
   - Value changes are properly detected and trigger replacement
   - Matches provider's ForceNew behavior exactly

## Verification Checklist

- ✅ Property in correct local (`azapi_header.location`)
- ✅ ForceNew wrapped: `{ value = var.location }`
- ✅ All logic EXACTLY replicated from provider (direct assignment, normalization handled by Azure)
- ✅ Validations appropriately handled (Required enforced, region names validated by Azure API)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work checked (following.md doesn't exist)
- ✅ Critical review completed (null, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis section added
- ✅ No additional code changes needed (Task #1 completed all implementation)
- ✅ Proof document created to verify and document Task #1's implementation
- ✅ Ready to update track.md status to "Pending for check"

## Conclusion

Task #2 (location) required no additional implementation because Task #1 exercised its special permission to create the complete `azapi_header` structure, which included full and correct implementation of the `location` field and its ForceNew behavior. This proof document verifies that the implementation is complete, correct, and matches provider behavior exactly.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-23
**Task:** #2 - location

### Validation Results

✅ **ForceNew Logic:** Correctly implemented using Mode 1 (Direct Value Tracking) with stable key wrapping: `location = { value = var.location }`
✅ **Stable Keys:** Key `location` is always present in `replace_triggers_external_values`
✅ **Phase Detection:** Field correctly placed in `local.azapi_header.location` (Create phase, top-level parameter)
✅ **Type Conversion:** Direct string assignment, no conversion needed
✅ **Null Handling:** Variable has `nullable = false` enforcing Required semantics
✅ **Validations:** Required enforced by `nullable = false`, Azure region validation appropriately deferred to Azure API per executor.md Category 1 rules
✅ **Deferred Work Completion:** No `following.md` file exists, no deferred work to complete
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed including null semantics, empty strings, case sensitivity, and idempotency

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The `location` field:
- Is correctly placed in `azapi_header.location` (top-level parameter, not in body)
- Has proper ForceNew behavior via `replace_triggers_external_values`
- Uses stable key wrapping to prevent false positive replacements
- Enforces Required constraint via `nullable = false`
- Appropriately relies on Azure API for region name validation

Task #1 exercised its documented special permission to create the complete `azapi_header` structure (executor.md lines 397-407), which included the `location` field. Task #2's verification confirms the implementation follows all executor.md rules exactly. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
